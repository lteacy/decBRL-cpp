/**
 * @file colourHarness.cpp
 * Test harness for learners based on graph colouring.
 * This is just a bandit problem, but the learners don't know that.
 */

#include "common.h"
#include "dec_brl/DecQLearner.h"
#include "MaxSumController.h"
#include<iostream>
#include <ctime>
#include <iomanip>
#include <cmath>
#include <set>
using namespace maxsum;
using namespace dec_brl;

/**
 * Scale factor used to divid random numbers in [0,1] to generate
 * a small random utility bias.
 */
const double BIAS_SCALE_M = 1000;

/**
 * Enumeration that represents the colours used in the graph colouring
 * problems generated by this test harness.
 */
enum Colour_m
{
   RED = 0,
   GREEN = 1,
   BLUE = 2,
   N_COLOURS = 3
};

/**
 * Convenience typedef for a map of factors.
 */
typedef std::map<FactorID,DiscreteFunction> FactorMap_m;

/**
 * Print information about a factor graph.
 */
void printFactorMap(const FactorMap_m& factors)
{
   std::cout << "FACTORMAP SIZE: " << factors.size() << std::endl;
   for(FactorMap_m::const_iterator fIt=factors.begin();
         fIt!=factors.end(); ++fIt)
   {

      std::cout << "Factor " << fIt->first << ": domain=<";
      bool printComma=false;
      for(DiscreteFunction::VarIterator vIt=fIt->second.varBegin();
            vIt!=fIt->second.varEnd(); ++vIt)
      {
         if(!printComma)
         {
            printComma=true;
         }
         else
         {
            std::cout << ',';
         }
         std::cout << *vIt;

      } // for loop
      std::cout << "> maxnorm=" << fIt->second.maxnorm();
      std::cout << " max=" << fIt->second.max();
      std::cout << " min=" << fIt->second.min();
      std::cout << " mean=" << fIt->second.mean();
      std::cout << std::endl;

   } // for loop

   std::cout << std::endl;

} // function printFactorMap


/**
 * Turns a function into a graph colouring utility function, based on its
 * domain. Each variable is functions domain is taken to be a colour variable.
 * The utility is defined as small random bias, minus the number of variables
 * that have the same colour.
 * @param factor the function that will be populated with the graph colour
 * utilities, based on its domain.
 */
void genColourUtil_m(DiscreteFunction& factor)
{
   //***************************************************************************
   // For each possible set of variable values in the function's domain
   //***************************************************************************
   for(DomainIterator it(factor); it.hasNext(); ++it)
   {
      //************************************************************************
      // Count the number of conflicts (i.e. variables with the same value)
      //************************************************************************
      std::set<ValIndex> uniqueVal(it.getSubInd().begin(),it.getSubInd().end());
      double noConflicts = it.getSubInd().size();
      noConflicts -= uniqueVal.size();

      //************************************************************************
      // Set the utility for the current position to be some small random
      // bias - the number of conflicts
      //************************************************************************
      double divider = BIAS_SCALE_M * RAND_MAX;
      double util = static_cast<double>(1+std::rand()) / divider;
      util -= noConflicts;
      factor(it) = util;

   } // for loop

} // function genColourUtil

/**
 * Function that generates a ring factor graph with a specified number of
 * factors.
 * @param[in] noFactors number of factors to generate
 * @param[out] factors map in which to store the generated factors.
 * @post any previous contents of <code>factors</code> will be destroyed.
 */
void genRingGraph_m(int noFactors, FactorMap_m& factors)
{
   //***************************************************************************
   // Clear any previous contents of the factor graph
   //***************************************************************************
   factors.clear();

   //***************************************************************************
   // Register all variables with domain size = number of colours
   //***************************************************************************
   for(int k=1; k<=noFactors; ++k)
   {
      registerVariable(k,N_COLOURS);
   }

   //***************************************************************************
   // Create each factor depending on its own variable, and those immediately
   // adjacent in the ring.
   //***************************************************************************
   VarID vars[2];
   for(int k=1; k<=noFactors; ++k)
   {
      //************************************************************************
      // Figure out which variables to connect to
      //************************************************************************
      vars[0]=((noFactors+k-2)%noFactors)+1;
      vars[1]=((k-1)%noFactors)+1;

      //************************************************************************
      // Initialise the function with this domain, and generated graph
      // colour utilities.
      //************************************************************************
      DiscreteFunction curFactor(vars,vars+2);
      genColourUtil_m(curFactor);
      factors[k] = curFactor;

   } // for loop
   
} // function genRingGraph

/**
 * Function that generates a fully connected factor graph with a specified
 * number of factors.
 * @param[in] noFactors number of factors to generate
 * @param[out] factors map in which to store the generated factors.
 * @post any previous contents of <code>factors</code> will be destroyed.
 */
void genFullGraph_m(int noFactors, FactorMap_m& factors)
{
   //***************************************************************************
   // Clear any previous contents of the factor graph
   //***************************************************************************
   factors.clear();

   //***************************************************************************
   // Register all variables with domain size = number of colours
   //***************************************************************************
   std::vector<VarID> vars(noFactors);
   for(int k=1; k<=noFactors; ++k)
   {
      registerVariable(k,N_COLOURS);
      vars[k-1]=k;
   }

   //***************************************************************************
   // Create factors which depend on all variables - thus graph is fully
   // connected.
   //***************************************************************************
   for(int k=1; k<=noFactors; ++k)
   {
      DiscreteFunction curFactor(vars.begin(),vars.end());
      genColourUtil_m(curFactor);
      factors[k]=curFactor;
   }

} // function genFullGraph

/**
 * Function that generates a tree graph with a specified depth and branching
 * factor. This function is implemented using recursion.
 * @param[in] depth the depth of the tree
 * @param[in] branchFactor the branching factor of the tree
 * @param[out] factors map in which to store the generated factors.
 * @param[in] nextID the id of the next factor to add to the graph.
 * @param[in] parentID the id of this factor's parent in the tree.
 * @returns the last factor id used by this call.
 * @post any previous contents of <code>factors</code> will be destroyed.
 */
int genTreeGraph_m
(
 int depth,
 int branchFactor,
 FactorMap_m& factors,
 int nextID=1,
 const int parentID=0
)
{
   //***************************************************************************
   // Clear any previous contents of the factor graph (both only if this
   // call is for the root of the tree).
   //***************************************************************************
   if(0==parentID)
   {
      factors.clear();
   }

   //***************************************************************************
   // Register the variable for this node.
   //***************************************************************************
   const int myID = nextID; // id of this factor
   registerVariable(myID,N_COLOURS);

   //***************************************************************************
   // Connect this factor to its own variable, and its parent's variable (if
   // not root).
   //***************************************************************************
   DiscreteFunction& curFactor = factors[nextID];
   curFactor.expand(myID);
   if(0!=parentID)
   {
      curFactor.expand(parentID);
   }

   //***************************************************************************
   // If this is a leaf node, then all we need to do is fill in the utility
   // values and stop.
   //***************************************************************************
   if(1>=depth)
   {
      genColourUtil_m(curFactor);
      return nextID;
   }

   //***************************************************************************
   // Otherwise, we first need to expand the tree along each branch
   //***************************************************************************
   for(int k=0; k<branchFactor; ++k)
   {
      //int nextChild = nextID+1;
      nextID = genTreeGraph_m(depth-1, branchFactor, factors, nextID+1, myID);
      //curFactor.expand(nextChild);
   }

   //***************************************************************************
   // Only now that the function domain is complete, can we fill in the
   // utility values, and return the nextID
   //***************************************************************************
   genColourUtil_m(curFactor);
   return nextID;

} // function genTreeGraph

/**
 * Ensures that a learner does throw any stupid errors, even if it doesn't
 * necessary choose good actions. Learner passed by value on purpose, so that
 * this test doesn't contaminate the original learner's state.
 * @returns the number of failures
 */
int testLearner_m(DecQLearner learner, const FactorMap_m& factors)
{
   int errorCount = 0;
   try
   {
      //************************************************************************
      // Initialise learner with factor graph structure
      //************************************************************************
      std::cout << "Initialising Learner...";
      for(FactorMap_m::const_iterator it=factors.begin();
            it!=factors.end(); ++it)
      {
         const FactorID id = it->first;
         const DiscreteFunction& fun = it->second;
         std::cout << "Adding Factor " << id << std::endl;
         learner.addFactor(id,fun.varBegin(),fun.varEnd());
      }

      //************************************************************************
      // Although the graph colouring problem is stateless (we just stole the
      // code from a previous max-sum library test harness) we still want some
      // states to test. We will therefore arbitrarily treat even numbered
      // variables between 0 and 10 as state variables, and everything else
      // as action variables. With this in mind, we create a variable map to
      // hold random states, and chosen actions.
      //************************************************************************
      std::map<VarID,ValIndex> priorStates; // used to hold prior states
      std::map<VarID,ValIndex> postStates; // used to hold post action states
      std::map<VarID,ValIndex> actions; // used to hold chosen actions
      std::map<FactorID,double> rewards; // used to hold observed rewards

      //************************************************************************
      // Tell the learner which variables we think are states
      //************************************************************************
      // Currently this step is done 'just in time' by act function, but we
      // may want to refactor this step into a separate function and call it
      // here.

      //************************************************************************
      // Start with some random post states - these become the prior 
      // states as soon as we enter the first iteration.
      //************************************************************************
      for(int s=0; s<=10; s+=2)
      {
         postStates[s] = std::rand() % N_COLOURS;
      }

      //************************************************************************
      // Run through a few learning iterations with this learner and factor
      // graph.
      //************************************************************************
      std::clock_t runtime = std::clock();
      int N_ITERATIONS = 10; // fixed number of iterations to run
      for(int k=0; k<N_ITERATIONS; ++k)
      {
         std::cout << "ITERATION: " << k << std::endl;

         //*********************************************************************
         // Post states from previous round now become prior states for this
         // round.
         //*********************************************************************
         postStates.swap(priorStates);

         //*********************************************************************
         // Ask learner to choose actions (action map will be populated by
         // learner).
         //*********************************************************************
         std::cout << "ACTION CHOSEN USING " << learner.act(priorStates,actions)
            << " MAXSUM ITERATIONS." << std::endl;

         //*********************************************************************
         // Display states and actions
         //*********************************************************************
         typedef std::map<VarID,ValIndex>::const_iterator Iterator;
         std::cout << "Number of states: " << priorStates.size() << std::endl;
         for(Iterator it=priorStates.begin(); it!=priorStates.end(); ++it)
         {
            std::cout << "STATE[" << it->first << "]=" << it->second
                      << std::endl;
         }

         std::cout << "Number of actions: " << actions.size() << std::endl;
         for(Iterator it=actions.begin(); it!=actions.end(); ++it)
         {
            std::cout << "ACTIONS[" << it->first << "]=" << it->second
                      << std::endl;
         }

         //*********************************************************************
         // Calculate the union of states and actions
         //*********************************************************************
         std::map<VarID,ValIndex> allVars;
         allVars.insert(priorStates.begin(),priorStates.end());
         allVars.insert(actions.begin(),actions.end());

         //*********************************************************************
         // Check that the learner hasn't treated any states as actions
         // (true iff size of state and action sets sum up to size of union)
         //*********************************************************************
         if(allVars.size() != (priorStates.size()+actions.size()))
         {
            ++errorCount;
            std::cout << "Learner thinks some states are actions." << std::endl;
         }

         //*********************************************************************
         // Calculate the observed rewards, by querying the values of the
         // original factor map over the union of states and actions
         //*********************************************************************
         for(FactorMap_m::const_iterator it=factors.begin();
               it!=factors.end(); ++it)
         {
            rewards[it->first] = it->second(allVars);
         }

         //*********************************************************************
         // Populate the posterior state map with random colours
         //*********************************************************************
         for(int s=0; s<=10; s+=2)
         {
            postStates[s] = std::rand() % N_COLOURS;
         }

         //*********************************************************************
         // Let the learner observe the factored rewards
         //*********************************************************************
         learner.observe(priorStates,actions,postStates,rewards);

      } // outer for loop

      //************************************************************************
      // Stop the clock, and print out the run time
      //************************************************************************
      runtime = std::clock() - runtime;
      double seconds = static_cast<double>(runtime) / CLOCKS_PER_SEC;
      std::cout << "DONE. TOTAL RUNTIME=" << seconds;
      std::cout << std::endl;

   }
   //***************************************************************************
   // Deal with any unexpected exceptions
   //***************************************************************************
   catch(std::exception& e)
   {
      std::cout << "Caught unexpected exception: " << e.what();
      ++errorCount;
      return errorCount;
   }

   //***************************************************************************
   // Return the total number of encountered errors
   //***************************************************************************
   return errorCount;

} // function testLearner_m

/**
 * Main function tests a learner on several factor graphs.
 */
int main()
{
   int errorCount = 0; // counts the number of failures
   try
   {
      FactorMap_m factors; // Reusable FactorMap for storing current factors
      DecQLearner learner; // Greedy Learner for testing
      std::clock_t runtime = std::clock();

      //************************************************************************
      // Test behaviour of an uninitialised learner
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on empty graph                               *\n";
      std::cout << "********************************************************\n";
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;

      //************************************************************************
      // Test on singleton graph, containing only one factor and variable
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on singleton graph                           *\n";
      std::cout << "********************************************************\n";
      genTreeGraph_m(1,1,factors);
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;
   
      //************************************************************************
      // Create a MaxSumController and test it on a line graph (i.e. tree graph
      // with branching factor of 1.
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on line graph                                *\n";
      std::cout << "********************************************************\n";
      genTreeGraph_m(10,1,factors);
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;

      //************************************************************************
      // Test on ring with same number of factors
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on ring graph                                *\n";
      std::cout << "********************************************************\n";
      genRingGraph_m(10,factors);
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;

      //************************************************************************
      // Test on tree with additional factors
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on tree graph                                *\n";
      std::cout << "********************************************************\n";
      genTreeGraph_m(4,2,factors);
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;

      //************************************************************************
      // Test on fully connected graph with last factors.
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on colourable fully connected graph          *\n";
      std::cout << "********************************************************\n";
      genFullGraph_m(N_COLOURS,factors);
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;

      //************************************************************************
      // Test on fully connected graph with last factors.
      //************************************************************************
      std::cout << "********************************************************\n";
      std::cout << "* Testing on non-colourable fully connected graph      *\n";
      std::cout << "********************************************************\n";
      genFullGraph_m(N_COLOURS+2,factors);
      printFactorMap(factors);
      errorCount += testLearner_m(learner,factors);
      std::cout << std::endl;

      //************************************************************************
      // Report the total runtime and number of failures.
      //************************************************************************
      runtime = std::clock() - runtime;
      float seconds = static_cast<float>(runtime) / CLOCKS_PER_SEC;
      std::cout << "********************************************************\n";
      std::cout << "* TOTAL RUNTIME: " << std::setw(6) << std::setfill('0');
      std::cout << std::setprecision(3) << std::fixed;
      std::cout << seconds <<  "   NUMBER OF ERRORS: ";
      std::cout << std::setw(4) << std::setfill(' ');
      std::cout << errorCount << "       *\n";
      std::cout << "********************************************************\n";
   }
   catch(std::exception e)
   {
      std::cout << "\nCaught unexpected exception in main: " << e.what();
      std::cout << std::endl;
      ++errorCount;
   }

   //***************************************************************************
   // Return success if all tests in this harness have passed.
   //***************************************************************************
   if(0==errorCount)
   {
      return EXIT_SUCCESS;
   }
   return EXIT_FAILURE;

} // function main




